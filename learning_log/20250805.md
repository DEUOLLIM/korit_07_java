# 입실 체크 해주세요 !! 😶‍🌫️
# md 파일 생성
# 자격 증명 체크 - 제 아이디 아닌거보니까 확인하셔야합니다.
# 금일 수업 계획
1. 배열 (Array)
2. 천천히 한다
3. 복습도 한다
4. 금일 이름 역순 면담

# 접근 지정자 추가 설명
## public -> 모든 곳에서 접근이 가능
    1. 완전히 공개된 상태
    2. 누구든지 사용 가능
    3. 보통 라이브러리나 API의 공개된 기능에 사용됨.
```java
public class Car {
    // 필드 선언 및 초기화
    public String model = "셀토스";
    
    // 메서드 정의
    public void drive() {
        System.out.println("자동차를 운전합니다.");
    }
}
```
이상의 코드는 다른 어떤 클래스를 생성하더라도 경로만 정확하다면 Car car1 = new Car();로
객체를 생성할 수 있고(class가 public이니까), System.out.println(car1.model);이라고 했을 때
'셀토스'라는 String 데이터가 콘솔에 찍힐겁니다(field가 public이니까). 마지막으로 car1.drive();
를 호출해도 콘솔에 "자동차를 운전합니다."라는 텍스트가 콘솔에 나올겁니다(method가 public이니까).

## privte -> 자기 클래스 내부에서만 접근 가능
1. 가장 제한적인 접근 지정자
2. 클래스 외부에서는 전혀 접근할 수 없음
3. 데이터 보호 목적으로 사용
```java
public class Car {
    private String engine = "V6";
    
    public void showEngine() {
        System.out.println("엔진 정보 : " + engine);
    }
} 
// 별개의 클래스
public class CarMain {
    public static void main(String[] args) {
        // 객체 생성
        Car car1 = new Car();
        System.out.println(car1.engine);    // 컴파일링 오류 : 필드 자체는 private
        car1.showEngine();  // 엔진 정보 : V6 라고 출력됨 -> method는 public이기 때문에
    }
}
```
Car를 기준으로 field는 private / 일부 정보만 공개하게 되는 method는 public이기 때문에
CarMain에서 객체를 생성하는 것 가능(class level - public) /
엔진 정보를 직접 조회하는 것(car1.engine)은 불가능 field는 private이니까
하지만 method를 경유하여 조회하는 것은 가능(car1.showEngine()) - method는 public이니까.

## protected -> 같은 패키지 + 상속(추후 수업)관계에서 접근 가능
기본적으로 추후에 배울 default와 같지만 자식 클래스에서 상속 받아서 사용 가능
```java
package vehicle;

public class Car {
    protected String brand = "기아";
}

// 같은 패키지의 다른 클래스
package vehicle;

import vehicle.Car;

public class MyCar extends Car {    // extends는 상속 관계를 나타내는 키워드
    public void showBrand() {
        System.out.println(brand);
    }
}
```
추후 상속 개념을 학습했을 때 더 자세히 알 수 있지만 Car 클래스의 protected 필드인
brand를 동일한 패키지의 MyCar 클래스에서 '직접 조회'했습니다(Getter와 같은 메서드를
경유한 것이 아니라).

## (default) - 아무 접근 지정자도 없을 때(package-private)
1. 같은 패키지 안에서는 접근 가능, 다른 패키지에서는 불가능
```java
class Car {
    String color = "red";
}
```
이상의 경우, class 레벨도 default / field 레벨도 default라고 볼 수 있습니다.
그리고 저희는 여태까지 챕터 단위로 패키지를 만들었고 그 안에서 객체 생성을 했었기 때문에
ch08_methods 이후로 별 문제 없이 패키지 내에서 클래스를 만들고
(Car / CarMain을 만들고), 객체를 생성하고, 필드도 조회하고, 메서드도 호출가능했었습니다.

앞으로의 수업부터는 접근 지정자를 분명하게 명시하여 개발자인 여러분들이 직접 통제하도록
진행될 예정입니다.

## 실무적인 관점에서의 접근 지정자 선택
1. 필드는 원칙적으로 -> private
2. 메서드는 외부 공개 필요시 -> public
3. 상속 대상 메서드는 -> protected
4. 패키지 내부에서만 쓰이는 도우미 클래스 -> (default)

### 항상 그런 것은 아니지만 염두해두면 좋은 부분
1. 필드는 웬만하면 private으로 지정하고, 접근은 getter / setter를 통하자(자동완성이 public인 이유)
2. 인터페이스나 라이브러리는 public을 최소화할 것. 이미 공개된 API는 되돌리기 어려움
    - 다른 회사가 내가 만든 class를 쓰고 있는데 멀쩡하게 public으로 되어있던게 default로 바뀌게 되면
      그 회사는 더이상 제가 만든 class를 사용하지 못하게 될거고, 기존 로직을 다 갈아엎어야할겁니다.
# 전체 복습(쉬운 버전)
ch11_access_modifier -> CharacterMain 클래스 생성

# 배열(Array)
## 배열의 필요성
여태까지의 수업을 기준으로 하면 10 개의 정수형 데이터를 저장하려면 int 변수를 10 개 선언해서 저장해야 합니다.
배열은 '같은' 자료형의 데이터를 하나의 변수에 저장해서 관리하는 방식입니다. -> Java에서입니다
즉 113번 라인과 같은 상황에서 하나의 변수만 가지고 내부에 10 개의 int 데이터를 저장할 수 있음을 뜻합니다.

## 선언 방식
자료형[] 변수명
```java
형식 :
자료형[] 변수명 = 데이터;
int[] arr01 = { 1, 2, 3, 4, 5 }; // 그럼 얘는 변수 선언 및 초기화에 해당하겠네요.

```
----------------------------------------------------------------------------------------------------------------------
## 클래스(class)
클래스는 객체를 만들기위한 설계도
public class Dog { // 클래스 이름 Dog
    String name;
    int age;

    public void bark(){   // bark는 메서드
        System.out.print(name + "가 짖어요!")
    }
}

## 객체 생성
클래스에서 만든 인스턴스
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog(); // 객체 생성, myDog 는 참조변수(객체를 가리킴), Dog??
        mayDog.name = "멍멍이";
        myDog.age = 3;
        myDog.bark();
    }
}

## 메서드
어떤 작업을 수행하는 코드 블럭(함수와 비슷)
public void greet(String name) {
    System,out.println("안녕,"  +  name  +  "!")
}

## 메서드 형식
[접근제어자] [반환형] [메서드이름](매개변수) {
// 실행 코드
}
    
## getter / setter
객체는 private 필드를 직접 접근하지 못하도록 보호하고, 대신 접근/ 수정하는 메서드를 제공
public class Person {
    private String name;  // 클래스 외부에서 직접 접근을 막는 접근 제어자   

    // getter
    public String getName() {
        return name;
    }

    // setter
    public void setName(String name) {
        this.name = name;
    }
}

## 배열 선언과 생성
int[] scores;            // 배열 선언 (참조 변수 선언)
scores = new int[5];     // 크기가 5인 int형 배열 생성

## 한줄에 선언과 생성
int[] scores = new int[5];

# 배열 초기화
int[] scores = {90, 85, 78, 92, 88};  // 초기값 지정해서 배열 생성

# 배열 길이
int length = scores.length; // 배열의 크기(길이) 구하기

# 배열과 반복
for (int i = 0; i < scores.length; i++) {
System.out.println("점수 " + i + ": " + scores[i]);
}

# 접근 제한
private, 외부클래스(다른 클래스)에서 직접 접근할 수 없고 
getter와 setter 메서드를 통해 간접 접근하게 만든다.

# 왜 private를 쓰나요?
데이터 보호, 데이터 무결성 유지 목적

외부에서 마음대로 값을 바꾸는 걸 막고, 값 변경 규칙을 메서드로 통제할 수 있어요.





